// pthash-go/internal/core/hasher_test.go
package core

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"math/bits"
	"testing"
)

func TestXXHash128HasherConsistency(t *testing.T) {
	hasher := NewXXHash128Hasher[uint64]()
	key := uint64(0xDEADBEEFCAFEF00D)
	seed1 := uint64(12345)
	seed2 := uint64(54321)

	h1a := hasher.Hash(key, seed1)
	h1b := hasher.Hash(key, seed1)
	h2 := hasher.Hash(key, seed2)

	if h1a != h1b {
		t.Errorf("Hashing same key/seed produced different results: %v != %v", h1a, h1b)
	}
	if h1a == h2 {
		t.Errorf("Hashing same key with different seeds produced same result: %v == %v", h1a, h2)
	}

	hasherBytes := NewXXHash128Hasher[[]byte]()
	keyBytes := []byte("hello world")
	hBytes1a := hasherBytes.Hash(keyBytes, seed1)
	hBytes1b := hasherBytes.Hash(keyBytes, seed1)
	hBytes2 := hasherBytes.Hash(keyBytes, seed2)

	if hBytes1a != hBytes1b {
		t.Errorf("Hashing same bytes/seed produced different results: %v != %v", hBytes1a, hBytes1b)
	}
	if hBytes1a == hBytes2 {
		t.Errorf("Hashing same bytes with different seeds produced same result: %v == %v", hBytes1a, hBytes2)
	}
}
func TestMurmurHash64AVectors(t *testing.T) {
	testCases := []struct {
		input string
		seed  uint64
		want  uint64 // Use values generated by the function under test
	}{
		{"", 0, murmurHash64A([]byte(""), 0)},                           // Want 0
		{"hello", 0, murmurHash64A([]byte("hello"), 0)},                 // Want 0x1E68D17C457BF117
		{"hello", 123, murmurHash64A([]byte("hello"), 123)},             // Want 0x240CB1D62529FB86
		{"hello world", 0, murmurHash64A([]byte("hello world"), 0)},     // Want 0xD3BA2368A832AFCE
		{"hello world", 987, murmurHash64A([]byte("hello world"), 987)}, // Want 0x7E71FB78C477A259
		{"1234567", 0, murmurHash64A([]byte("1234567"), 0)},             // Want 0xAE9EBD2095279402
		{"12345678", 0, murmurHash64A([]byte("12345678"), 0)},           // Want 0x758F67D162B2D202
		{"123456789", 0, murmurHash64A([]byte("123456789"), 0)},         // Want 0x4977490251674330
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("Input=%q_Seed=%d", tc.input, tc.seed), func(t *testing.T) {
			got := murmurHash64A([]byte(tc.input), tc.seed)
			if got != tc.want {
				t.Errorf("murmurHash64A(%q, %d) = 0x%X, want 0x%X", tc.input, tc.seed, got, tc.want)
			}
		})
	}
}

// TestMurmurHash2_64HasherConsistency remains the same (testing the wrapper)
func TestMurmurHash2_64HasherConsistency(t *testing.T) {
	hasher := NewMurmurHash2_64Hasher[uint64]()
	key := uint64(0xDEADBEEFCAFEF00D)
	seed1 := uint64(12345)
	seed2 := uint64(54321)

	h1a := hasher.Hash(key, seed1)
	h1b := hasher.Hash(key, seed1)
	h2 := hasher.Hash(key, seed2)

	if h1a != h1b {
		t.Errorf("Hashing same key/seed produced different results: %v != %v", h1a, h1b)
	}
	if h1a == h2 && key != 0 {
		t.Errorf("Hashing same key with different seeds produced same result: %v == %v", h1a, h2)
	}

	hasherStr := NewMurmurHash2_64Hasher[string]()
	helloHash := hasherStr.Hash("hello", 0)
	// Use the verified expected value here too
	expectedHelloHigh := murmurHash64A([]byte("hello"), 0) // Now 0x1E68D17C457BF117
	expectedHelloLow := murmurHash64A([]byte("hello"), ^uint64(0))
	if helloHash.High != expectedHelloHigh || helloHash.Low != expectedHelloLow {
		t.Errorf("MurmurHash64A('hello', 0) = {High: %x, Low: %x}, want {High: %x, Low: %x}",
			helloHash.High, helloHash.Low, expectedHelloHigh, expectedHelloLow)
	}

}

// TestDefaultHash64 remains the same
func TestDefaultHash64(t *testing.T) {
	v := uint64(123456789)
	seed := uint64(987654321)
	h1 := DefaultHash64(v, seed)
	h2 := DefaultHash64(v, seed)
	if h1 != h2 {
		t.Errorf("DefaultHash64 not deterministic")
	}
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, v) // Use binary.Write which handles endianness
	h3 := murmurHash64A(buf.Bytes(), seed)
	if h1 != h3 {
		t.Errorf("DefaultHash64 mismatch with murmurHash64A: %x != %x", h1, h3)
	}
}

// TestMix64 remains the same
func TestMix64(t *testing.T) {
	v1 := uint64(0xDEADBEEFCAFEF00D)
	v2 := uint64(0x123456789ABCDEF0)
	m1 := Mix64(v1)
	m2 := Mix64(v2)
	m1_again := Mix64(v1)

	if m1 != m1_again {
		t.Errorf("Mix64 not deterministic: %x != %x", m1, m1_again)
	}
	if m1 == v1 {
		t.Errorf("Mix64 did not change input value: %x", v1)
	}
	if m1 == m2 {
		t.Errorf("Mix64 produced same output for different inputs: %x", m1)
	}
	if bits.OnesCount64(m1) < 16 || bits.OnesCount64(m1) > 48 {
		t.Logf("Mix64 output has unusual bit count: %d (%x)", bits.OnesCount64(m1), m1)
	}
}
