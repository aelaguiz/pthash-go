#!/usr/bin/env python3
import re
import argparse
import os

# Markers in the Go test file (same as before)
M64_MARKER_START = "// PASTE_M64_CASES_HERE_START"
M64_MARKER_END = "// PASTE_M64_CASES_HERE_END"
MUL128_MARKER_START = "// PASTE_MUL128_CASES_HERE_START"
MUL128_MARKER_END = "// PASTE_MUL128_CASES_HERE_END"
FASTMOD64_MARKER_START = "// PASTE_FASTMOD64_CASES_HERE_START"
FASTMOD64_MARKER_END = "// PASTE_FASTMOD64_CASES_HERE_END"

# Markers expected in the generated values file
M64_GEN_START = "// === Expected M64 Go Test Cases ==="
M64_GEN_END = "// === END M64 ==="
MUL128_GEN_START = "// === Expected mul128_u64 Go Test Cases ==="
MUL128_GEN_END = "// === END mul128_u64 ==="
FASTMOD64_GEN_START = "// === Expected FastModU64 Go Test Cases ==="
FASTMOD64_GEN_END = "// === END FastModU64 ==="


def extract_section(content, start_marker, end_marker):
    """Extracts lines between start and end markers."""
    lines = []
    in_section = False
    for line in content.splitlines():
        if start_marker in line:
            in_section = True
            continue # Skip the marker line itself
        if end_marker in line:
            in_section = False
            break # Stop extracting when the specific end marker is found
        if in_section:
            # Append line as is (generator script handles formatting/commas)
            lines.append(line)
    # Join lines, preserving relative indentation from generator if any
    return "\n".join(lines)

def inject_section(go_template_content, section_content, start_marker, end_marker):
    """Injects section content between markers in the template."""
    start_idx = go_template_content.find(start_marker)
    end_idx = go_template_content.find(end_marker)

    if start_idx == -1 or end_idx == -1 or end_idx <= start_idx:
        raise ValueError(f"Markers '{start_marker}' or '{end_marker}' not found or in wrong order.")

    # Get indentation from the line *containing* the end marker
    # This is usually more reliable if the markers are on their own lines.
    indent = ""
    end_line_start = go_template_content.rfind('\n', 0, end_idx) + 1
    end_line = go_template_content[end_line_start:end_idx]
    match = re.match(r"^(\s*)", end_line)
    if match:
        indent = match.group(1)

    # Indent the section content if it's not empty
    indented_section = ""
    if section_content.strip():
         indented_section = "\n".join([indent + line for line in section_content.splitlines()])
         indented_section += "\n" # Add trailing newline for readability


    # Replace content between markers (exclusive of markers themselves)
    # Find end of start marker line and start of end marker line
    start_inject_pos = go_template_content.find('\n', start_idx) + 1
    end_inject_pos = go_template_content.rfind('\n', 0, end_idx) + 1


    return (go_template_content[:start_inject_pos] +
            indented_section +
            go_template_content[end_inject_pos:])
def main():
    parser = argparse.ArgumentParser(description="Update Go fastmod tests with generated values.")
    parser.add_argument("expected_values_file", help="Path to the file generated by generate_test_values.py (e.g., script/expected_values.txt)")
    parser.add_argument("go_test_file", help="Path to the Go test file to update (e.g., internal/core/fastmod_verify_test.go)")
    args = parser.parse_args()

    if not os.path.exists(args.expected_values_file):
        print(f"Error: Expected values file not found: {args.expected_values_file}")
        exit(1)
    if not os.path.exists(args.go_test_file):
        print(f"Error: Go test file not found: {args.go_test_file}")
        exit(1)

    print(f"Reading expected values from: {args.expected_values_file}")
    with open(args.expected_values_file, 'r') as f:
        expected_content = f.read()

    print(f"Reading Go test template from: {args.go_test_file}")
    with open(args.go_test_file, 'r') as f:
        go_template_content = f.read()

    # Extract sections using specific start/end markers from the generated file
    m64_section = extract_section(expected_content, M64_GEN_START, M64_GEN_END)
    mul128_section = extract_section(expected_content, MUL128_GEN_START, MUL128_GEN_END)
    fastmod64_section = extract_section(expected_content, FASTMOD64_GEN_START, FASTMOD64_GEN_END)

    # Check if sections were found
    if not m64_section.strip(): print("Warning: No M64 values extracted.")
    if not mul128_section.strip(): print("Warning: No mul128_u64 values extracted.")
    if not fastmod64_section.strip(): print("Warning: No FastModU64 values extracted.")

    # Inject sections into Go template using the markers in the Go file
    try:
        print("Injecting M64 section...")
        updated_go_content = inject_section(go_template_content, m64_section, M64_MARKER_START, M64_MARKER_END)
        print("Injecting mul128 section...")
        updated_go_content = inject_section(updated_go_content, mul128_section, MUL128_MARKER_START, MUL128_MARKER_END)
        print("Injecting FastMod64 section...")
        updated_go_content = inject_section(updated_go_content, fastmod64_section, FASTMOD64_MARKER_START, FASTMOD64_MARKER_END)
    except ValueError as e:
        print(f"Error injecting sections: {e}")
        exit(1)

    # Write updated content back to Go test file
    print(f"Writing updated tests to: {args.go_test_file}")
    try:
        with open(args.go_test_file, 'w') as f:
            f.write(updated_go_content)
        print("Successfully updated Go test file.")
    except IOError as e:
        print(f"Error writing to Go test file: {e}")
        exit(1)

if __name__ == "__main__":
    main()
