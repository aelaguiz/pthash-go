#!/usr/bin/env python3
import re
import argparse
import os

# Markers in the Go test file
M64_MARKER_START = "// PASTE_M64_CASES_HERE_START"
M64_MARKER_END = "// PASTE_M64_CASES_HERE_END"
MUL128_MARKER_START = "// PASTE_MUL128_CASES_HERE_START"
MUL128_MARKER_END = "// PASTE_MUL128_CASES_HERE_END"
FASTMOD64_MARKER_START = "// PASTE_FASTMOD64_CASES_HERE_START"
FASTMOD64_MARKER_END = "// PASTE_FASTMOD64_CASES_HERE_END"

def extract_section(content, start_marker, end_marker):
    """Extracts lines between start and end markers."""
    lines = []
    in_section = False
    for line in content.splitlines():
        if start_marker in line:
            in_section = True
            continue # Skip the marker line itself
        if end_marker in line:
            in_section = False
            break # Stop after end marker
        if in_section:
            lines.append(line)
    # Add comma to the last actual test case line if needed
    if lines:
        # Find last non-empty, non-comment line that likely needs a comma
        for i in range(len(lines) - 1, -1, -1):
             trimmed_line = lines[i].strip()
             if trimmed_line and not trimmed_line.startswith("//") and not trimmed_line.endswith(","):
                 # Basic check: assumes last meaningful line is the end of a struct literal
                 if trimmed_line.endswith("}"):
                     lines[i] += ","
                 break # Only add comma to the presumed last case

    return "\n".join(lines)

def inject_section(go_template_content, section_content, start_marker, end_marker):
    """Injects section content between markers in the template."""
    start_idx = go_template_content.find(start_marker)
    end_idx = go_template_content.find(end_marker)

    if start_idx == -1 or end_idx == -1 or end_idx <= start_idx:
        raise ValueError(f"Markers '{start_marker}' or '{end_marker}' not found or in wrong order.")

    # Get indentation from the line after the start marker
    indent = ""
    start_line_end = go_template_content.find('\n', start_idx)
    if start_line_end != -1:
        next_line_start = start_line_end + 1
        next_line_end = go_template_content.find('\n', next_line_start)
        if next_line_end != -1:
             following_line = go_template_content[next_line_start:next_line_end]
             match = re.match(r"^(\s*)", following_line)
             if match:
                 indent = match.group(1)


    # Indent the section content
    indented_section = "\n".join([indent + line for line in section_content.splitlines()])

    # Add trailing newline if section is not empty
    if indented_section.strip():
        indented_section += "\n"


    return (go_template_content[:start_idx + len(start_marker)] +
            "\n" + indented_section +
            go_template_content[end_idx:])


def main():
    parser = argparse.ArgumentParser(description="Update Go fastmod tests with generated values.")
    parser.add_argument("expected_values_file", help="Path to the file generated by generate_test_values.py (e.g., script/expected_values.txt)")
    parser.add_argument("go_test_file", help="Path to the Go test file to update (e.g., internal/core/fastmod_verify_test.go)")
    args = parser.parse_args()

    if not os.path.exists(args.expected_values_file):
        print(f"Error: Expected values file not found: {args.expected_values_file}")
        exit(1)
    if not os.path.exists(args.go_test_file):
        print(f"Error: Go test file not found: {args.go_test_file}")
        exit(1)

    print(f"Reading expected values from: {args.expected_values_file}")
    with open(args.expected_values_file, 'r') as f:
        expected_content = f.read()

    print(f"Reading Go test template from: {args.go_test_file}")
    with open(args.go_test_file, 'r') as f:
        go_template_content = f.read()

    # Extract sections from expected values
    m64_section = extract_section(expected_content, "=== Expected M64 Values ===", "===")
    mul128_section = extract_section(expected_content, "=== Expected mul128_u64 High Values ===", "===")
    fastmod64_section = extract_section(expected_content, "=== Expected FastModU64 Values ===", "===")

    # Check if sections were found
    if not m64_section.strip(): print("Warning: No M64 values extracted.")
    if not mul128_section.strip(): print("Warning: No mul128_u64 values extracted.")
    if not fastmod64_section.strip(): print("Warning: No FastModU64 values extracted.")


    # Inject sections into Go template
    try:
        updated_go_content = inject_section(go_template_content, m64_section, M64_MARKER_START, M64_MARKER_END)
        updated_go_content = inject_section(updated_go_content, mul128_section, MUL128_MARKER_START, MUL128_MARKER_END)
        updated_go_content = inject_section(updated_go_content, fastmod64_section, FASTMOD64_MARKER_START, FASTMOD64_MARKER_END)
    except ValueError as e:
        print(f"Error injecting sections: {e}")
        exit(1)

    # Write updated content back to Go test file
    print(f"Writing updated tests to: {args.go_test_file}")
    try:
        with open(args.go_test_file, 'w') as f:
            f.write(updated_go_content)
        print("Successfully updated Go test file.")
    except IOError as e:
        print(f"Error writing to Go test file: {e}")
        exit(1)

if __name__ == "__main__":
    main()